#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from realadv.attack import make_data_range
from realadv.cudnn_wrap import enforce_conv_fwd_algo
from realadv.utils import Flatten, assign_param, torch_as_npy

import torch
import torch.nn as nn
import numpy as np

from contextlib import contextmanager
import argparse
import pickle

def make_torch_model(model, mm):
    if mm:
        w = model['weights_mm'][:]
        layers = [Flatten(), nn.Linear(*w[0].shape)]
        w[0] = w[0].T
    else:
        w = model['weights'][:]
        ic, oc, fh, fw = w[0].shape
        assert fh == fw
        layers = [nn.Conv2d(1, oc, fh), Flatten()]

    for i in range(2, len(w), 2):
        layers.extend([
            nn.ReLU(),
            nn.Linear(*w[i].shape)
        ])
        w[i] = w[i].T

    ret = nn.Sequential(*layers)
    params = list(ret.parameters())
    assert len(params) == len(w)
    for i, j in zip(params, w):
        assign_param(i, j)
    return ret

def attack(model, x0, eps, weights_mm, winograd):
    def clip(x):
        x = torch.min(x, xmax, out=x)
        x = torch.max(x, xmin, out=x)
        return x

    def get_iscore(x):
        y = model[:-2](x)
        return y.flatten().item()

    def get_cw(x):
        pred = np.squeeze(torch_as_npy(model(x)), axis=0)
        return pred[1] - pred[0]

    xmin, xmax = make_data_range(x0, eps)
    _, _, ih, iw = x0.shape

    wmm_all = weights_mm[0]
    for i in range(2, len(weights_mm) - 2, 2):
        wmm_all = wmm_all @ weights_mm[i]
    adv_sign = np.sign(wmm_all).reshape(x0.shape)
    delta = torch.from_numpy(adv_sign * (eps + 1e-4)).to(x0.device)
    xadv = clip(x0 + delta)
    cw0 = get_cw(xadv)

    rng = np.random.RandomState(92702102)
    iscore = get_iscore(xadv)

    for iter_num in range(10000):
        xt = xadv.clone()
        h, w = rng.randint(ih), rng.randint(iw)
        xt[:, :, h, w] += rng.uniform(-2e-7, 2e-7)
        xt = clip(xt)
        if (s := get_iscore(xt)) > iscore:
            iscore = s
            xadv = xt
            print(f'iter {iter_num}: {iscore=}')

    cw = get_cw(xadv)
    print(f'{cw0=} {cw=}')
    return cw < 0

@contextmanager
def setup_algo(cuda_conv, winograd):
    if cuda_conv:
        if winograd:
            name = 'WINOGRAD_NONFUSED'
        else:
            name = 'IMPLICIT_GEMM'
        with enforce_conv_fwd_algo(name):
            yield
    else:
        yield

def main():
    parser = argparse.ArgumentParser(
        description='attack a model generated by gen_robust.py',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('model')
    parser.add_argument('--winograd', action='store_true')
    parser.add_argument('--mm', action='store_true')
    parser.add_argument('--cpu', action='store_true')
    args = parser.parse_args()

    device = 'cpu' if args.cpu else 'cuda'

    with open(args.model, 'rb') as fin:
        model = pickle.load(fin)

    assert model['input'].shape[-1] == 1
    torch_model_mm = make_torch_model(model, True).to(device)
    torch_model_conv = make_torch_model(model, False).to(device)
    torch_model = torch_model_mm if args.mm else torch_model_conv
    print(torch_model)
    inp = torch.from_numpy(np.ascontiguousarray(
        np.transpose(model['input'], (2, 0, 1))[None]))
    inp = inp.to(device)

    with setup_algo(not args.cpu, False):
        chkmm = torch_model_mm[:2](inp)
        chkconv = torch_model_conv[:2](inp)
        assert torch.allclose(chkmm, chkconv)

    with setup_algo(not args.mm and not args.cpu, args.winograd):
        succ = attack(torch_model, inp, model['eps'], model['weights_mm'],
                      args.winograd)
    print(f'{succ=}')

if __name__ == '__main__':
    main()
